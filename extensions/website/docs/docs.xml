<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<javascript>
    <class type="ActiveController" superclass="Object">
        <examples>
            <example><![CDATA[ActiveController.js
===============
Tutorial coming soon.]]></example>
        </examples>
    </class>
    <class type="ActiveEvent" superclass="Object">
        <examples>
            <example><![CDATA[ActiveEvent.js
==============

ActiveEvent allows you to create observable events, and attach event
handlers to any class or object.
Setup
-----
Before you can use ActiveEvent you must call extend a given class or object
with ActiveEvent's methods. If you extend a class, both the class itself
will become observable, as well as all of it's instances.
    ActiveEvent.extend(MyClass); //class and all instances are observable
    ActiveEvent.extend(my_object); //this object becomes observable

Creating Events
---------------
You can create an event inside any method of your class or object by calling
the notify() method with name of the event followed by any arguments to be
passed to observers. You can also have an existing method fire an event with
the same name as the method using makeObservable().

    var Message = function(){};
    Message.prototype.send = function(text){
        //message sending code here...
        this.notify('sent',text);
    };
    ActiveEvent.extend(Message);

    //make an existing method observable
    var observable_hash = new Hash({});
    ActiveEvent.extend(observable_hash);
    observable_hash.makeObservable('set');

Observing Events
----------------
To observe an event call the observe() method with the name of the event you
want to observe, and the observer function. The observer function will
receive any additional arguments passed to notify(). If observing a class,
the instance that triggered the event will always be the first argument
passed to the observer. observeOnce() works just like observe() in every
way, but is only called once.

    Message.observe('sent',function(message,text){
        //responds to all sent messages
    });

    var m = new Message();
    m.observe('sent',function(text){
        //this will only be called when "m" is sent
    });

    observable_hash.observe('set',function(key,value){
        console.log('observable_hash.set: ' + key + '=' + value);
    });
    observable_hash.observeOnce(function(key,value){
        //this will only be called once
    });

Control Flow
------------
When notify() is called, if any of the registered observers for that event
return false, no other observers will be called and notify() will return
false. Returning null or not calling return will not stop the event.
Otherwise notify() will return an array of the
collected return values from any registered observer functions. Observers
can be unregistered with the stopObserving() method. If no observer is
passed, all observers of that object or class with the given event name
will be unregistered. If no event name and no observer is passed, all
observers of that object or class will be unregistered.
    Message.prototype.send = function(text){
        if(this.notify('send',text) === false)
            return false;
        //message sending code here...
        this.notify('sent',text);
        return true;
    };

    var m = new Message();
    
    var observer = m.observe('send',function(message,text){
        if(text === 'test')
            return false;
    });
    
    m.send('my message'); //returned true
    m.send('test'); //returned false
    
    m.stopObserving('send',observer);
    
    m.send('test'); //returned true</code></pre>

Object.options
--------------
If an object has an options property that contains a callable function with
the same name as an event triggered with <b>notify()</b>, it will be
treated just like an instance observer. So the falling code is equivalent.
    var rating_one = new Control.Rating('rating_one',{  
        afterChange: function(new_value){}    
    });  
    
    var rating_two = new Control.Rating('rating_two');  
    rating_two.observe('afterChange',function(new_value){});</code></pre>

MethodCallObserver
------------------
The makeObservable() method permanently modifies the method that will
become observable. If you need to temporarily observe a method call without
permanently modifying it, use the observeMethod(). Pass the name of the
method to observe and the observer function will receive all of the
arguments passed to the method. An ActiveEvent.MethodCallObserver object is
returned from the call to observeMethod(), which has a stop() method on it.
Once stop() is called, the method is returned to it's original state. You
can optionally pass another function to observeMethod(), if you do the
MethodCallObserver will be automatically stopped when that function
finishes executing.

    var h = new Hash({});
    ActiveEvent.extend(h);
    
    var observer = h.observeMethod('set',function(key,value){
        console.log(key + '=' + value);
    });
    h.set('a','one');
    h.set('a','two');
    observer.stop();
    
    //console now contains:
    //"a = one"
    //"b = two"
    
    //the following does the same as above
    h.observeMethod('set',function(key,value){
        console.log(key + '=' + value);
    },function(){
        h.set('a','one');
        h.set('b','two');
    });]]></example>
        </examples>
        <methods>
            <method name="extend" scope="static">
                <description>After extending a given object, it will inherit the methods described in ActiveEvent.ObservableObject.</description>
                <parameters>
                    <parameter name="object" usage="required" type="Object"/>
                </parameters>
            </method>
        </methods>
    </class>
    <class type="ActiveEvent.ObservableObject" superclass="Object">
        <description>After calling ActiveEvent.extend(object), the given object will inherit the methods in this namespace. If the given object has a prototype (is a class constructor), the object&apos;s prototype will inherit these methods as well.</description>
        <methods>
            <method name="makeObservable" scope="static">
                <description>Wraps the given method_name with a function that will call the method, then trigger an event with the same name as the method. This can safely be applied to virtually any method, including built in Objects (Array.pop, etc), but cannot be undone.</description>
                <parameters>
                    <parameter name="method_name" usage="required" type="String"/>
                </parameters>
            </method>
            <method name="notify" scope="static">
                <description>Triggers event_name with the passed arguments.</description>
                <parameters>
                    <parameter name="event_name" usage="required" type="String"/>
                    <parameter name="args" usage="optional" type="mixed"/>
                </parameters>
                <return-types>
                    <return-type type="mixed">
                        <description>Array of return values, or false if the event was stopped by an observer.</description>
                    </return-type>
                </return-types>
            </method>
            <method name="observe" scope="static">
                <parameters>
                    <parameter name="event_name" usage="required" type="String"/>
                    <parameter name="observer" usage="required" type="Function"/>
                </parameters>
                <return-types>
                    <return-type type="Function">
                        <description>observer</description>
                    </return-type>
                </return-types>
            </method>
            <method name="observeMethod" scope="static">
                <description>Similiar to makeObservable(), but after the callback is called, the method will be returned to it&apos;s original state and will no longer be observable.</description>
                <parameters>
                    <parameter name="method_name" usage="required" type="String"/>
                    <parameter name="observe" usage="required" type="Function"/>
                    <parameter name="callback" usage="optional" type="Function"/>
                </parameters>
            </method>
            <method name="observeOnce" scope="static">
                <description>Works exactly like observe(), but will stopObserving() after the next time the event is fired.</description>
                <parameters>
                    <parameter name="event_name" usage="required" type="String"/>
                    <parameter name="observer" usage="required" type="Function"/>
                </parameters>
                <return-types>
                    <return-type type="Function">
                        <description>The observer that was passed in will be wrapped, this generated / wrapped observer is returned.</description>
                    </return-type>
                </return-types>
            </method>
            <method name="stopObserving" scope="static">
                <description>Removes a given observer. If no observer is passed, removes all observers of that event. If no event is passed, removes all observers of the object.</description>
                <parameters>
                    <parameter name="event_name" usage="optional" type="String"/>
                    <parameter name="observer" usage="optional" type="Function"/>
                </parameters>
            </method>
        </methods>
    </class>
    <class type="ActiveRecord" superclass="Object">
        <examples>
            <example><![CDATA[ActiveRecord.js
===============

ActiveRecord.js is a cross browser, cross platform, stand-alone object
relational mapper. It shares a very similar vocabulary to the Ruby
ActiveRecord implementation, but uses JavaScript idioms and best
practices -- it is not a direct port. It can operate using an in memory
hash table, or with a SQL back end on the Jaxer platform (SQLite and
MySQL), Adobe's AIR (SQLite) and Google Gears (SQLite). Support
for the HTML 5 SQL storage spec is planned.

Setup
-----
To begin using ActiveRecord.js, you will need to include the
activerecord.js file and establish a connection. If you do not specify
a connection type, one will be automatically chosen.

    ActiveRecord.connect();

You can also specify a specific type of adapter. Jaxer requires
pre-configuring of the database for the entire application, and Gears
automatically configures the database, so simply passing the type of
connection is enough. In all of the SQLite implementations you can
optionally specify a database name (browser) or path (Jaxer):

    ActiveRecord.connect(ActiveRecord.Adapters.InMemory); //in JS memory
    ActiveRecord.connect(ActiveRecord.Adapters.JaxerMySQL); //Jaxer MySQL
    ActiveRecord.connect(ActiveRecord.Adapters.JaxerSQLite); //Jaxer SQLite
    ActiveRecord.connect(ActiveRecord.Adapters.AIR); //Adobe AIR
    ActiveRecord.connect(ActiveRecord.Adapters.Gears,'my_database'); //Gears or HTML5, name is optional
    
Once connected you can always execute SQL statements directly:

    ActiveRecord.execute('CREATE TABLE IF NOT EXISTS posts (id INTEGER PRIMARY KEY, user_id, title, text)');
    
Logging (to either the Jaxer log or browser console) can be turned on by setting:

    ActiveRecord.logging = true;

InMemory Adapter
----------------
If you are using a browser or platform that does not have access to a SQL
database, you can use the InMemory adapter which will store your objects
in memory. All features (including find by SQL) will still work, but you
will not be able to use the Migration features, since there is no table
schema. Since your objects will not persist, the second parameter to
establish a connection is a hash with the data you would like to use
in this format: {table_name: {id: row}}. The InMemory adapter will also
trigger three observable events that allow you to write an AJAX
persistence layer.

    ActiveRecord.connect(ActiveRecord.Adapters.InMemory,{
        table_one: {
            1: {row_data},
            2: {row_data}
        },
        table_two: {
            1: {row_data},
            2: {row_data}
        }
    });

    ActiveRecord.connection.observe('created',function(table_name,id,data){});
    ActiveRecord.connection.observe('updated',function(table_name,id,data){});
    ActiveRecord.connection.observe('destroyed',function(table_name,id){});
    
Defining Your Model
-------------------
ActiveRecord classes are created using the ActiveRecord.create method which
takes three arguments: the name of the table that the class will reference,
a field definition hash, and optionally a hash of instance methods that
will be added to the class. If the table does not exist it will be
automically created.
    var User = ActiveRecord.create('users',{
        username: '',
        password: '',
        post_count: 0,
        profile: {
            type: 'TEXT',
            value: ''
        }
    },{
        getProfileWordCount: function(){
            return this.get('profile').split(/\s+/).length;
        }
    });

Class & Instance Methods
------------------------
JavaScript does not have true static methods or classes, but in this case any
method of the User variable above is refered to as a class method, and any
method of a particular user (that the User class would find) is refered to as
an instance method. The most important class methods are create() and find():

    var jessica = User.create({
        username: 'Jessica',
        password: 'rabbit'
    });

Add new class or instance methods to all ActiveRecord models in the following
way:

    ActiveRecord.ClassMethods.myClassMethod = function(){
        //this === model class
    };
    ActiveRecord.InstanceMethods.myInstanceMethod = function(){
        // this === model instance
    };

Getters & Setters
-----------------
It is extremely important to note that all of the attributes/columns of the user
are accessible directly for reading (for convenience), but cannot be written
directly. You **must** use the set() method to set an attribute, you **should**
use the get() method to access all attributes, but you **must** use the get()
method if your attribute/column is a method of the object or a JavaScript
reserved keyword ('save,'initialize','default', etc).

    jessica.username // 'Jessica'
    jessica.get('username'); // 'Jessica'
    jessica.username = 'new username';
    jessica.get('username'); // 'Jessica'
    jessica.set('username','new username');
    jessica.get('username'); // 'new username'

When Data is Persisted
----------------------
Data is only persisted to the database in three cases: when you explicitly call
save() on a record, when you call create() on a record, or create a child record
through a relationship (the method will contain the word "create" in this case),
or when you call updateAttribute() on a record. In the case of the latter, only
the attribute you update will be saved, the rest of the record will not be
persisted to the database, even if changes have been made. Calling save() may
add an "id" property to the record if it does not exist, but if there are no
errors, it's state will otherwise be unchanged. You can call refresh() on any
record to ensure it is not out of synch with your database at any time.

Finding Records
---------------
If you created the User class using the define() method you automatically have
free "finder" methods:

    User.findByUsername('Jessica');
    User.findAllByPassword(''); //finds all with blank passwords

Otherwise you can use the base find() method, which takes a hash of options,
a numeric id or a complete SQL string:

    var posts = Post.find({
        all: true,
        order: 'id DESC',
        limit: 10
    });

Synchronization
---------------
It is sometimes useful to keep records that have already been found in synch
with the database. Each found record has a synchronize() method that will keep
the values of that record in synch with the database. If you pass the parameter
synchronize: true to find(), all objects will have their values synchronized,
and in addition the result set itself will update as objects are destroyed or
created. Both features are relatively expensive operations, and are not
automatically garbage collected/stopped when the record or result set goes
out of scope, so you will need to explicitly stop both record and result set
synchronization.

    var aaron = User.findByName('aaron');
    aaron.synchronize();

    var aaron_clone = User.findByName('aaron');
    aaron_clone.set('name','Aaron!');
    aaron_clone.save();

    aaron.get('name') === 'Aaron!';
    aaron.stop(); //record will no longer be synchronized

    var users = User.find({
        all: true,
        synchronize: true
    });
    //users contains aaron
    aaron.destroy();
    //users will no longer contain aaron
    users.stop(); //result set will no longer be synchronized

Calculations (count, min, max, etc) can also be synchronized. As a second
parameter to the calculation function, pass a hash with a synchronize
property that contains a function. That function will be called when the
result of the calculation changes. Instead of returning the value of the
calculation the initial call to the calculation function will return a
function that will stop the synchronization.
    var current_count;
    var stop = User.count({
        synchronize: function(updated_count){
            current_count = updated_count;
        }
    });
    var new_user = User.create({params}); //current_count incremented
    new_user.destroy();  //current_count decremented
    stop();
    User.create({params}); //current_count unchanged
Lifecycle
---------
There are 8 currently supported lifecycle events which allow granular control
over your data, and are convenient to build user interface components and
interactions around on the client side:

- afterFind
- afterInitialize
- beforeSave
- afterSave
- beforeCreate
- afterCreate
- beforeDestroy
- afterDestroy

beforeSave and afterSave are called when both creating (inserting) and saving
(updating) a record. You can observe events on all instances of a class, or
just a particular instnace:

    User.observe('afterCreate',function(user){
        console.log('User with id of ' + user.id + ' was created.');
    });

    var u = User.find(5);
    u.observe('afterDestroy',function(){
        //this particular user was destroyed
    });

In the example above, each user that is created will be passed to the first
callback. You can also call stopObserving() to remove a given observer, and
use the observeOnce() method (same arguments as observe()) method if needed.
Alternately, each event name is also a convience method and the following
example is functionally equivelent to the prior example:

    User.afterCreate(function(user){
        console.log('User with id of ' + user.id + ' was created.');
    });

    var u = User.find(5);
    u.afterDestroy(function(){
        //this particular user was destroyed
    });

You can stop the creation, saving or destruction of a record by returning
false inside any observers of the beforeCreate, beforeSave and
beforeDestroy events respectively:

    User.beforeDestroy(function(user){
        if(!allow_deletion_checkbox.checked){
            return false; //record will not be destroyed
        }
    });
Returning null, or returning nothing is equivelent to returning true in
this context and will not stop the event.
    
To observe a given event on all models, you can do the following: 

    ActiveRecord.observe('created',function(model_class,model_instance){});
    
afterFind works differently than all of the other events. It is only available
to the model class, not the instances, and is called only when a result set is
found. A find first, or find by id call will not trigger the event.

    User.observe('afterFind',function(users,params){
        //params contains the params used to find the array of users
    });
    
Validation
----------
Validation is performed on each model instance when create() or save() is
called. Validation can be applied either by using pre defined validations
(validatesPresenceOf, validatesLengthOf, more will be implemented soon), or by
defining a valid() method in the class definition. (or by both). If a record is
not valid, save() will return false. create() will always return the record,
but in either case you can call getErrors() on the record to determine if
there are any errors present.

    User = ActiveRecord.define('users',{
        username: '',
        password: ''
    },{
        valid: function(){
            if(User.findByUsername(this.username)){
                this.addError('The username ' + this.username + ' is already taken.');
            }
        }
    });

    User.validatesPresenceOf('password');

    var user = User.build({
        'username': 'Jessica'
    });

    user.save(); //false
    var errors = user.getErrors(); //contains a list of the errors that occured
    user.set('password','rabbit');
    user.save(); //true
    
Relationships
-------------
Relationships are declared with one of three class methods that are available
 to all models:

- belongsTo
- hasMany
- hasOne

The related model name can be specified in a number of ways, assuming that you
have a Comment model already declared, any of the following would work:

    User.hasMany(Comment)
    User.hasMany('Comment')
    User.hasMany('comment')
    User.hasMany('comments')

Each relationship adds various instance methods to each instance of that
model. This differs significantly from the Rails "magical array" style of
handling relationship logic:

Rails:

    u = User.find(5)
    u.comments.length
    u.comments.create :title => 'comment title'

ActiveRecord.js:

    var u = User.find(5);
    u.getCommentList().length;
    u.createComment({title: 'comment title'});

You can name the relationship (and thus the generate methods) by passing
a name parameter:

    TreeNode.belongsTo(TreeNode,{name: 'parent'});
    TreeNode.hasMany(TreeNode,{name: 'child'});
    //instance now have, getParent(), getChildList(), methods

Missing Features
----------------
ActiveRecord.js will not support all of the advanced features of the Ruby
ActiveRecord implementation, but several key features are currently missing
and will be added soon:

- complete set of default validations from ActiveRecord::Validations::ClassMethods
- ActsAsList
- ActsAsTree
- hasMany :through (which will likely be the only supported many to many relationship)]]></example>
        </examples>
        <properties>
            <property name="adapter" access="read-write" scope="static" type="mixed">
                <description>null if no connection is active, or the class that created the connection.</description>
            </property>
            <property name="autoMigrate" access="read-write" scope="static" type="Boolean">
                <description>Will automatically create a table when create() is called. Defaults to true.</description>
            </property>
            <property name="ClassMethods" access="read-write" scope="static" type="Object">
                <description>Contains all methods that will become available to ActiveRecord classes.</description>
            </property>
            <property name="connection" access="read-write" scope="static" type="mixed">
                <description>null if no connection is active, or the connection object.</description>
            </property>
            <property name="InstanceMethods" access="read-write" scope="static" type="Object">
                <description>Contains all methods that will become available to ActiveRecord instances.</description>
            </property>
            <property name="internalCounter" access="read-write" scope="static" type="Number">
                <description>Tracks the number of records created.</description>
            </property>
            <property name="logging" access="read-write" scope="static" type="Boolean">
                <description>Defaults to false.</description>
            </property>
            <property name="Models" access="read-write" scope="static" type="Object">
                <description>Contains model_name, ActiveRecord.Class pairs.</description>
            </property>
        </properties>
        <methods>
            <method name="connect" scope="static">
                <description>Must be called before using ActiveRecord. If the adapter requires arguments, those must be passed in after the type of adapter.</description>
                <examples>
                    <example><![CDATA[    ActiveRecord.connect(ActiveRecord.Adapters.JaxerSQLite,'path_to_database_file');
    ActiveRecord.adapter === ActiveRecord.Adapters.JaxerSQLite;
    ActiveRecord.connection.executeSQL('SELECT * FROM sqlite_master');
    //or you can have ActiveRecord try to auto detect the enviornment
    ActiveRecord.connect();]]></example>
                </examples>
                <parameters>
                    <parameter name="adapter" usage="required" type="Object"/>
                    <parameter name="args" usage="optional" type="mixed"/>
                </parameters>
            </method>
            <method name="create" scope="static">
                <description>Creates an ActiveRecord class, returning the class and storing it inside ActiveRecord.Models [ model_name ] . model_name is a singularized, capitalized form of table name.</description>
                <examples>
                    <example><![CDATA[    var User = ActiveRecord.create('users');
    var u = User.find(5);]]></example>
                </examples>
                <parameters>
                    <parameter name="table_name" usage="required" type="String"/>
                    <parameter name="fields" usage="required" type="Object">
                        <description>Should consist of column name, default value pairs. If an empty array or empty object is set as the default, any arbitrary data can be set and will automatically be serialized when saved. To specify a specific type, set the value to an object that contains a &quot;type&quot; key, with optional &quot;length&quot; and &quot;value&quot; keys.</description>
                    </parameter>
                    <parameter name="methods" usage="optional" type="Object"/>
                </parameters>
                <return-types>
                    <return-type type="Object"/>
                </return-types>
            </method>
            <method name="define" scope="static">
                <description>If the table for your ActiveRecord does not exist, this will define the ActiveRecord and automatically create the table.</description>
                <examples>
                    <example><![CDATA[    var User = ActiveRecord.define('users',{
        name: '',
        password: '',
        comment_count: 0,
        profile: {
            type: 'text',
            value: ''
        },
        serializable_field: {}
    });
    var u = User.create({
        name: 'alice',
        serializable_field: {a: '1', b: '2'}
    });]]></example>
                </examples>
                <parameters>
                    <parameter name="table_name" usage="required" type="String"/>
                    <parameter name="fields" usage="required" type="Object">
                        <description>Should consist of column name, default value pairs. If an empty array or empty object is set as the default, any arbitrary data can be set and will automatically be serialized when saved. To specify a specific type, set the value to an object that contains a &quot;type&quot; key, with optional &quot;length&quot; and &quot;value&quot; keys.</description>
                    </parameter>
                    <parameter name="methods" usage="optional" type="Object"/>
                    <parameter name="readyCallback" usage="optional" type="Function">
                        <description>Must be specified if running in asynchronous mode.</description>
                    </parameter>
                </parameters>
                <return-types>
                    <return-type type="Object"/>
                </return-types>
            </method>
            <method name="escape" scope="static">
                <description>Escapes a given argument for use in a SQL string. By default the argument passed will also be enclosed in quotes.</description>
                <parameters>
                    <parameter name="argument" usage="required" type="mixed"/>
                    <parameter name="supress_quotes" usage="optional" type="Boolean">
                        <description>Defaults to false.</description>
                    </parameter>
                </parameters>
                <return-types>
                    <return-type type="mixed">
                        <description>ActiveRecord.escape(5) == 5 ActiveRecord.escape(&apos;tes&quot;t&apos;) == &apos;&quot;tes\&quot;t&quot;&apos;;</description>
                    </return-type>
                </return-types>
            </method>
            <method name="execute" scope="static">
                <description>Execute a SQL statement on the active connection. If the statement requires arguments they must be passed in after the SQL statement.</description>
                <examples>
                    <example><![CDATA[    ActiveRecord.execute('DELETE FROM users WHERE user_id = ?',5);]]></example>
                </examples>
                <parameters>
                    <parameter name="sql" usage="required" type="String"/>
                </parameters>
                <return-types>
                    <return-type type="mixed"/>
                </return-types>
            </method>
            <method name="observe" scope="static">
                <description>Observe an event on all models. observer will be called with model_class, model_instance.</description>
                <parameters>
                    <parameter name="event_name" usage="required" type="String"/>
                    <parameter name="observer" usage="required" type="Function"/>
                </parameters>
                <return-types>
                    <return-type type="Array">
                        <description>Array of observers</description>
                    </return-type>
                </return-types>
            </method>
        </methods>
    </class>
    <class type="ActiveRecord.Adapters" superclass="Object">
        <properties>
            <property name="Auto" access="read-write" scope="static" type="ActiveRecord.Adapter">
                <description>Default adapter, will try to automatically pick the appropriate adapter for the current environment.</description>
            </property>
            <property name="Gears" access="read-write" scope="static" type="ActiveRecord.Adapter">
                <description>Adapter for browsers supporting a SQL implementation (Gears, HTML5).</description>
            </property>
            <property name="InMemory" access="read-write" scope="static" type="ActiveRecord.Adapter">
                <description>In memory, non persistent storage.</description>
            </property>
        </properties>
    </class>
    <class type="ActiveRecord.Class" superclass="Object">
        <description>Each generated class will inherit all of the methods in this class, in addition to the ones dynamically generated by finders, validators, relationships, or your own definitions.</description>
        <methods>
            <method name="addValidator" scope="static">
                <description>Adds the validator to the _validators array of a given ActiveRecord.Class.</description>
                <parameters>
                    <parameter name="validator" usage="required" type="Function"/>
                </parameters>
            </method>
            <method name="average" scope="static">
                <description>options can contain all params that find() can</description>
                <parameters>
                    <parameter name="column_name" usage="required" type="String"/>
                    <parameter name="params" usage="optional" type="Object"/>
                </parameters>
                <return-types>
                    <return-type type="Number"/>
                </return-types>
            </method>
            <method name="belongsTo" scope="static">
                <description>Sepcifies a 1&lt;-1 relationship between models. The foreign key will reside in the declaring object.</description>
                <examples>
                    <example><![CDATA[    Comment.belongsTo('User',{
        counter: 'comment_count' //comment count must be a column in User
    });
    var c = Comment.find(5);
    //each Comment instance will gain the following 3 methods
    c.getUser()
    c.buildUser()
    c.createUser()]]></example>
                </examples>
                <parameters>
                    <parameter name="related_model_name" usage="required" type="String">
                        <description>Can be a plural or singular referring to the related table, the model name, or a reference to the model itself (&quot;users&quot;,&quot;User&quot; or User would all work).</description>
                    </parameter>
                    <parameter name="options" usage="optional" type="Object">
                        <description>Can contain { String } &quot;foreignKey&quot;, { String } name, { String } &quot;counter&quot; keys.</description>
                    </parameter>
                </parameters>
            </method>
            <method name="build" scope="static">
                <description>Identical to calling create(), but does not save the record.</description>
                <parameters>
                    <parameter name="data" usage="required" type="Object"/>
                </parameters>
                <return-types>
                    <return-type type="ActiveRecord.Instance"/>
                </return-types>
            </method>
            <method name="count" scope="static">
                <description>options can contain all params that find() can</description>
                <parameters>
                    <parameter name="params" usage="optional" type="Object"/>
                </parameters>
                <return-types>
                    <return-type type="Number"/>
                </return-types>
            </method>
            <method name="create" scope="static">
                <examples>
                    <example><![CDATA[    var u = User.create({
        name: 'alice',
        password: 'pass'
    });
    u.id //will now contain the id of the user]]></example>
                </examples>
                <parameters>
                    <parameter name="data" usage="required" type="Object"/>
                </parameters>
                <return-types>
                    <return-type type="ActiveRecord.Instance"/>
                </return-types>
            </method>
            <method name="destroy" scope="static">
                <description>Deletes a given id (if it exists) calling any callbacks or validations on the record. If &quot;all&quot; is passed as the ids, all records will be found and destroyed.</description>
                <parameters>
                    <parameter name="id" usage="required" type="Number"/>
                </parameters>
                <return-types>
                    <return-type type="Boolean"/>
                </return-types>
            </method>
            <method name="find" scope="static">
                <description>Find a given record, or multiple records matching the passed conditions.</description>
                <examples>
                    <example><![CDATA[    var user = User.find(5); //finds a single record
    var user = User.find({
        first: true,
        where: {
            id: 5
        }
    });
    var user = User.find({
        first: true,
        where: ['id = ?',5]
    });
    var users = User.find(); //finds all
    var users = User.find({
        where: 'name = "alice" AND password = "' + md5('pass') + '"',
        order: 'id DESC'
    });
    //using the where syntax below, the parameters will be properly escaped
    var users = User.find({
        where: {
            name: 'alice',
            password: md5('pass')
        }
        order: 'id DESC'
    });
    var users = User.find('SELECT * FROM users ORDER id DESC');]]></example>
                </examples>
                <parameters>
                    <parameter name="params" usage="required" type="mixed">
                        <description>Can be an integer to try and find a record by id, a complete SQL statement String, or Object of params, params may contain: select: Array of columns to select (default [ &apos;*&apos; ] ) where: String or Object or Array joins: String order: String limit: Number offset: Number synchronize: Boolean</description>
                    </parameter>
                </parameters>
                <return-types>
                    <return-type type="mixed">
                        <description>If finding a single record, response will be Boolean false or ActiveRecord.Instance. Otherwise an Array of ActiveRecord.Instance s will be returned (which may be empty).</description>
                    </return-type>
                </return-types>
            </method>
            <method name="first" scope="static">
                <description>Returns the first record sorted by id.</description>
                <return-types>
                    <return-type type="ActiveRecord.Instance"/>
                </return-types>
            </method>
            <method name="hasMany" scope="static">
                <description>Sepcifies a 1-&gt;N relationship between models. The foreign key will reside in the child (related) object.</description>
                <examples>
                    <example><![CDATA[    User.hasMany('comments',{
        dependent: true
    });
    var u = User.find(5);
    //each User instance will gain the following 5 methods
    u.createComment()
    u.buildComment()
    u.destroyComment()
    u.getCommentList() //takes the same options as find()
    u.getCommentCount() //takes the same options as count()]]></example>
                </examples>
                <parameters>
                    <parameter name="related_model_name" usage="required" type="String">
                        <description>Can be a plural or singular referring to the related table, the model name, or a reference to the model itself (&quot;users&quot;,&quot;User&quot; or User would all work).</description>
                    </parameter>
                    <parameter name="options" usage="optional" type="Object">
                        <description>Can contain { String } &quot;foreignKey&quot;, { Sting } &quot;name&quot;, { Boolean } &quot;dependent&quot;, { String } &quot;order&quot; and { String } &quot;where&quot; keys.</description>
                    </parameter>
                </parameters>
            </method>
            <method name="hasOne" scope="static">
                <description>Sepcifies a 1-&gt;1 relationship between models. The foreign key will reside in the related object.</description>
                <examples>
                    <example><![CDATA[    User.hasOne(CreditCard);
    var u = User.find(5);
    //each User instance will gain the following 3 methods
    u.getCreditCard()
    u.buildCreditCard()
    u.createCreditCard()]]></example>
                </examples>
                <parameters>
                    <parameter name="related_model_name" usage="required" type="String">
                        <description>Can be a plural or singular referring to the related table, the model name, or a reference to the model itself (&quot;users&quot;,&quot;User&quot; or User would all work).</description>
                    </parameter>
                    <parameter name="options" usage="optional" type="Object">
                        <description>Can contain { String } &quot;foreignKey&quot;, { String } &quot;name&quot;, { Boolean } &quot;dependent&quot; keys.</description>
                    </parameter>
                </parameters>
            </method>
            <method name="last" scope="static">
                <description>Returns the last record sorted by id.</description>
                <return-types>
                    <return-type type="ActiveRecord.Instance"/>
                </return-types>
            </method>
            <method name="max" scope="static">
                <description>options can contain all params that find() can</description>
                <parameters>
                    <parameter name="column_name" usage="required" type="String"/>
                    <parameter name="params" usage="optional" type="Object"/>
                </parameters>
                <return-types>
                    <return-type type="Number"/>
                </return-types>
            </method>
            <method name="min" scope="static">
                <description>options can contain all params that find() can</description>
                <parameters>
                    <parameter name="column_name" usage="required" type="String"/>
                    <parameter name="params" usage="optional" type="Object"/>
                </parameters>
                <return-types>
                    <return-type type="Number"/>
                </return-types>
            </method>
            <method name="resultSetFromArray" scope="static">
                <description>Extends a vanilla array with ActiveRecord.ResultSet methods allowing for the construction of custom result set objects from arrays where result sets are expected. This will modify the array that is passed in and return the same array object.</description>
                <examples>
                    <example><![CDATA[    var one = Comment.find(1);
    var two = Comment.find(2);
    var result_set = Comment.resultSetFromArray([one,two]);]]></example>
                </examples>
                <parameters>
                    <parameter name="result_set" usage="required" type="Array"/>
                    <parameter name="params" usage="optional" type="Object"/>
                </parameters>
                <return-types>
                    <return-type type="Array"/>
                </return-types>
            </method>
            <method name="sum" scope="static">
                <description>options can contain all params that find() can</description>
                <parameters>
                    <parameter name="column_name" usage="required" type="String"/>
                    <parameter name="params" usage="optional" type="Object"/>
                </parameters>
                <return-types>
                    <return-type type="Number"/>
                </return-types>
            </method>
            <method name="transaction" scope="static">
                <examples>
                    <example><![CDATA[    Account.transaction(function(){
        var from = Account.find(2);
        var to = Account.find(3);
        to.despoit(from.withdraw(100.00));
    });]]></example>
                </examples>
                <parameters>
                    <parameter name="proceed" usage="required" type="Function">
                        <description>The block of code to execute inside the transaction.</description>
                    </parameter>
                    <parameter name="error" usage="optional" type="Function">
                        <description>Optional error handler that will be called with an exception if one is thrown during a transaction. If no error handler is passed the exception will be thrown.</description>
                    </parameter>
                </parameters>
            </method>
            <method name="update" scope="static">
                <examples>
                    <example><![CDATA[    Article.update(3,{
        title: 'New Title'
    });
    //or pass an array of ids and an array of attributes
    Article.update([5,7],[
        {title: 'Title for 5'},
        {title: 'Title for 7'}
    ]);]]></example>
                </examples>
                <parameters>
                    <parameter name="id" usage="required" type="Number"/>
                    <parameter name="attributes" usage="required" type="Object"/>
                </parameters>
                <return-types>
                    <return-type type="ActiveRecord.Instance"/>
                </return-types>
            </method>
            <method name="updateAll" scope="static">
                <parameters>
                    <parameter name="updates" usage="required" type="Object">
                        <description>A string of updates to make, or a Hash of column value pairs.</description>
                    </parameter>
                    <parameter name="conditions" usage="optional" type="String">
                        <description>Optional where condition, or Hash of column name, value pairs.</description>
                    </parameter>
                </parameters>
            </method>
            <method name="validatesLengthOf" scope="static">
                <description>Accepts &quot;min&quot; and &quot;max&quot; numbers as options.</description>
                <parameters>
                    <parameter name="field" usage="required" type="String"/>
                    <parameter name="options" usage="optional" type="Object"/>
                </parameters>
            </method>
            <method name="validatesPresenceOf" scope="static">
                <parameters>
                    <parameter name="field" usage="required" type="String"/>
                    <parameter name="options" usage="optional" type="Object"/>
                </parameters>
            </method>
        </methods>
    </class>
    <class type="ActiveRecord.Errors" superclass="Object">
        <properties>
            <property name="ConnectionNotEstablished" access="read-write" scope="static" type="String"/>
            <property name="InvalidFieldType" access="read-write" scope="static" type="String"/>
            <property name="MethodDoesNotExist" access="read-write" scope="static" type="String"/>
        </properties>
    </class>
    <class type="ActiveRecord.Instance" superclass="Object">
        <description>Each found instance will inherit all of the methods in this class, in addition to the ones dynamically generated by finders, validators, relationships, or your own definitions.</description>
        <methods>
            <method name="addError" scope="static">
                <parameters>
                    <parameter name="message" usage="required" type="String"/>
                    <parameter name="field_name" usage="required" type="String"/>
                </parameters>
            </method>
            <method name="destroy" scope="static">
                <description>Removes the object from the database, but does not destroy the object in memory itself.</description>
                <return-types>
                    <return-type type="Boolean"/>
                </return-types>
            </method>
            <method name="get" scope="static">
                <description>Get a given key on the object. If your field name is a reserved word, or the name of a method (save, updateAttribute, etc) you must use the get() method to access the property. For convenience non reserved words (title, user_id, etc) can be accessed directly (instance.key_name)</description>
                <parameters>
                    <parameter name="key" usage="required" type="String"/>
                </parameters>
                <return-types>
                    <return-type type="mixed"/>
                </return-types>
            </method>
            <method name="getErrors" scope="static">
                <return-types>
                    <return-type type="Array"/>
                </return-types>
            </method>
            <method name="keys" scope="static">
                <description>Returns an array of the column names that the instance contains.</description>
                <return-types>
                    <return-type type="Array"/>
                </return-types>
            </method>
            <method name="reload" scope="static">
                <description>Loads the most current data for the object from the database.</description>
                <return-types>
                    <return-type type="Boolean"/>
                </return-types>
            </method>
            <method name="save" scope="static">
                <description>Persists the object, creating or updating as nessecary.</description>
                <parameters>
                    <parameter name="force_created_mode" usage="required" type="Boolean">
                        <description>Defaults to false, will force the record to act as if it was created even if an id property was passed.</description>
                    </parameter>
                </parameters>
                <return-types>
                    <return-type type="Boolean"/>
                </return-types>
            </method>
            <method name="set" scope="static">
                <description>Sets a given key on the object. You must use this method to set a property, properties assigned directly (instance.key_name = value) will not persist to the database and may cause errors.</description>
                <parameters>
                    <parameter name="key" usage="required" type="String"/>
                    <parameter name="value" usage="required" type="mixed"/>
                    <parameter name="surpress_notifications" usage="required" type="Boolean">
                        <description>Defaults to false</description>
                    </parameter>
                </parameters>
                <return-types>
                    <return-type type="mixed">
                        <description>the value that was set</description>
                    </return-type>
                </return-types>
            </method>
            <method name="stop" scope="static">
                <description>Stops the synchronization of the record with the database.</description>
                <return-types>
                    <return-type type="null"/>
                </return-types>
            </method>
            <method name="synchronize" scope="static">
                <description>Once synchronized a found instance will have it&apos;s values updated if other records with the same id change in the database.</description>
                <return-types>
                    <return-type type="null"/>
                </return-types>
            </method>
            <method name="toJSON" scope="static">
                <description>Serializes the record to an JSON string. If object_to_inject is passed that object will override any values of the record.</description>
                <parameters>
                    <parameter name="object_to_inject" usage="optional" type="Object"/>
                </parameters>
                <return-types>
                    <return-type type="String"/>
                </return-types>
            </method>
            <method name="toObject" scope="static">
                <description>Returns a &quot;clean&quot; version of the object, with just the data and no methods.</description>
                <return-types>
                    <return-type type="Object"/>
                </return-types>
            </method>
            <method name="toSerializableObject" scope="static">
                <description>toJSON and toXML will call this instead of toObject() to get the data they will serialize. By default this calls toObject(), but you can override this method to easily create custom JSON and XML output.</description>
                <return-types>
                    <return-type type="Object"/>
                </return-types>
            </method>
            <method name="toXML" scope="static">
                <description>Serializes the record to an XML string. If object_to_inject is passed that object will override any values of the record.</description>
                <parameters>
                    <parameter name="object_to_inject" usage="optional" type="Object"/>
                </parameters>
                <return-types>
                    <return-type type="String"/>
                </return-types>
            </method>
            <method name="updateAttribute" scope="static">
                <description>Sets a given key on the object and immediately persists that change to the database triggering any callbacks or validation .</description>
                <parameters>
                    <parameter name="key" usage="required" type="String"/>
                    <parameter name="value" usage="required" type="mixed"/>
                </parameters>
            </method>
            <method name="updateAttributes" scope="static">
                <description>Updates all of the passed attributes on the record and then calls save().</description>
                <parameters>
                    <parameter name="attributes" usage="required" type="Object"/>
                </parameters>
            </method>
            <method name="values" scope="static">
                <description>Returns an array of the column values that the instance contains.</description>
                <return-types>
                    <return-type type="Array"/>
                </return-types>
            </method>
        </methods>
    </class>
    <class type="ActiveRecord.Migrations" superclass="Object">
        <examples>
            <example><![CDATA[Migrations
----------

Migrations are a method of versioining the database schema used by your
application. All of your migrations must be defined in an object assigned
to ActiveRecord.Migrations.migrations. The keys need not be numerically
sequential, but must be numeric (i.e. 1,2,3 or 100,200,300).

Each migration object must have an up() and down() method which will
recieve an ActiveRecord.Migrations.Schema object. createTable() and
addColumn() both use the same syntax as define() to specify default
values and field types.

    ActiveRecord.Migrations.migrations = {
        1: {
            up: function(schema){
                schema.createTable('one',{
                    a: '',
                    b: {
                        type: 'TEXT',
                        value: 'default'
                    }
                });
            },
            down: function(schema){
                schema.dropTable('one');
            }
        },
        2: {
            up: function(schema){
                schema.addColumn('one','c');
            },
            down: function(schema){
                schema.dropColumn('one','c');
            }
        }
    };
    
    ActiveRecord.Migrations.migrate(); //will migrate to the highest available (2 in this case)
    ActiveRecord.Migrations.migrate(0); //migrates down below 1, effectively erasing the schema
    ActiveRecord.Migrations.migrate(1); //migrates to version 1]]></example>
        </examples>
        <methods>
            <method name="current" scope="static">
                <description>Returns the current schema version number.</description>
                <return-types>
                    <return-type type="Number"/>
                </return-types>
            </method>
            <method name="max" scope="static">
                <description>Returns the highest key name in the ActiveRecord.Migrations hash.</description>
                <return-types>
                    <return-type type="Number"/>
                </return-types>
            </method>
            <method name="migrate" scope="static">
                <description>Migrates a database schema to the given version.</description>
                <parameters>
                    <parameter name="target" usage="required" type="Number"/>
                </parameters>
            </method>
        </methods>
    </class>
    <class type="ActiveRecord.Migrations.Schema" superclass="Object">
        <description>This object is passed to all migrations as the only parameter.</description>
        <methods>
            <method name="addColumn" scope="static">
                <parameters>
                    <parameter name="table_name" usage="required" type="String"/>
                    <parameter name="column_name" usage="required" type="String"/>
                    <parameter name="data_type" usage="optional" type="mixed"/>
                </parameters>
            </method>
            <method name="addIndex" scope="static">
                <parameters>
                    <parameter name="table_name" usage="required" type="String"/>
                    <parameter name="column_names" usage="required" type="Array"/>
                    <parameter name="options" usage="required" type="Object"/>
                </parameters>
            </method>
            <method name="createTable" scope="static">
                <parameters>
                    <parameter name="table_name" usage="required" type="String"/>
                    <parameter name="columns" usage="required" type="Object"/>
                </parameters>
            </method>
            <method name="dropColumn" scope="static">
                <parameters>
                    <parameter name="table_name" usage="required" type="String"/>
                    <parameter name="column_name" usage="required" type="String"/>
                </parameters>
            </method>
            <method name="dropTable" scope="static">
                <parameters>
                    <parameter name="table_name" usage="required" type="String"/>
                </parameters>
            </method>
            <method name="removeIndex" scope="static">
                <parameters>
                    <parameter name="table_name" usage="required" type="String"/>
                    <parameter name="index_name" usage="required" type="String"/>
                </parameters>
            </method>
        </methods>
    </class>
    <class type="ActiveRecord.ResultSet" superclass="Object">
        <methods>
            <method name="reload" scope="static">
                <description>Re-runs the query that generated the result set. This modifies the array in place and does not return a new array.</description>
            </method>
            <method name="toArray" scope="static">
                <description>Builds an array calling toObject() on each instance in the result set, thus reutrning a vanilla array of vanilla objects.</description>
                <return-types>
                    <return-type type="Array"/>
                </return-types>
            </method>
            <method name="toJSON" scope="static">
                <return-types>
                    <return-type type="String"/>
                </return-types>
            </method>
            <method name="toXML" scope="static">
                <return-types>
                    <return-type type="String"/>
                </return-types>
            </method>
        </methods>
    </class>
    <class type="ActiveRoutes" superclass="Object">
        <examples>
            <example><![CDATA[ActiveRoutes.js
===============

ActiveRoutes maps URI strings to method calls, and visa versa. It shares a
similar syntax to Rails Routing, but is framework agnostic and can map
calls to any type of object. Server side it can be used to map requests for
a given URL to a method that will render a page, client side it can be used
to provide deep linking and back button / history support for your Ajax
application.

Declaring Routes
----------------
Wether declared in the constructor, or with addRoute(), routes can have up
to three parameters, and can be declared in any of the follow ways:

- "name", "path", {params}
- "path", {params}
- "path"

The path portion of a route is a URI string. Parameters that will be passed
to the method called are represented with a colon. Names are optional, but
the path and the params together must declare "object" and "method"
parameters. The following are all valid routes:

    var routes = new ActiveRoutes([
      ['root','/',{object:'Pages',method:'index'}],
      ['contact','/contact',{object:'Pages',method:'contact'}],
      ['blog','/blog',{object:'Blog',method:'index'}],
      ['post','/blog/post/:id',{object:'Blog',method:'post'}],
      ['/pages/*',{object:'Pages',method:'page'}],
      ['/:object/:method']
    ],Application);

Options
-------
You can pass a hash of options as the third parameter to the ActiveRoutes
constructor. This hash can contain the following keys:

- base: default '', the default path / url prefix to be used in a generated url
- classSuffix: default '' if it was "Controller", calling "/blog/post/5" would call BlogController.post instead of Blog.post
- dispatcher: default ActiveRoutes.prototype.defaultDispatcher, the dispatcher function to be called when dispatch() is called and a route is found
- camelizeObjectName: default true, if true, trying to call "blog_controller" through routes will call "BlogController"
- camelizeMethodName: default true, if true, trying to call "my_method_name" through routes will call "myMethodName"
- camelizeGeneratedMethods: default true, will export generated methods into the scope as "articleUrl" instead of "article_url"

Catch All Routes
----------------
If you want to route all requests below a certain path to a given method,
place an asterisk in your route. When a matching path is dispatched to
that route the path components will be available in an array called "path".

    route_set.addRoute('/wiki/*',{object:'WikiController',method:'page'})
    route_set.dispatch('/wiki/a/b/c');
    //calls: WikiController.page({object:'WikiController',method:'page',path:['a','b','c']})

Route Requirements
------------------
Each route can take a special "requirements" parameter that will not be
passed in the params passed to the called method. Each requirement
can be a regular expression or a function, which the value of the
parameter will be checked against. Each value checked by a regular
expression or function is always a string.

    route_set.addRoute('/article/:article_id/:comment_id',{
        article_id: /^\d+$/,
        comment_id: function(comment_id){
            return comment_id.match(/^\d+$/);
        }
    });

Scope
-----
You can specify what scope an ActiveRoutes instance will look in to call
the specified objects and methods. This defaults to window but can be
specified as the second parameter to the constructor.

Generating URLs
---------------
The method urlFor() is available on every route set, and can generate a
URL from an object. Using the routes declared in the example above:

    routes.urlFor({object:'Blog',method:'post',id:5}) == '/blog/post/5';

If named routes are given, corresponding methods are generated in the
passed scope to resolve these urls.

    Application.postUrl({id: 5}) == '/blog/post/5';

To get the params to generate a url, a similar method is generated:

    Application.postParams({id: 5}) == {object:'Blog',method:'post',id:5};

To call a named route directly without round-tripping to a string and
back to params use:

    Application.callPost({id: 5});
Dispatching
-----------
To call a given method from a URL string, use the dispatch() method.

    routes.dispatch('/'); //will call Pages.index()
    routes.dispatch('/blog/post/5'); //will call Blog.post({id: 5});

History
-------
Most server side JavaScript implementations will not preserve objects
between requests, so the history is not of use. Client side, after each
dispatch, the route and parameters are recorded. The history itself is
accessible with the "history" property, and is traversable with the
next() and back() methods.]]></example>
        </examples>
        <constructors>
            <constructor scope="instance">
                <parameters>
                    <parameter name="routes" usage="required" type="Array"/>
                    <parameter name="scope" usage="optional" type="Object">
                        <description>defaults to window</description>
                    </parameter>
                    <parameter name="options" usage="optional" type="Object"/>
                </parameters>
                <return-types>
                    <return-type type="ActiveRoutes"/>
                </return-types>
            </constructor>
        </constructors>
        <properties>
            <property name="defaultDispatcher" access="read-write" scope="instance" type="Function">
                <description>If no &quot;dispatcher&quot; key is passed into the options to contstruct a route set this is used. It will call scope.object_name.method_name(route.params)</description>
            </property>
            <property name="history" access="read-write" scope="instance" type="Array"/>
            <property name="logging" access="read-write" scope="static" type="Boolean"/>
        </properties>
        <methods>
            <method name="addRoute" scope="instance">
                <description>Add a new route to the route set. When adding routes via the constructor routes will be pushed onto the array, if called after the route set is initialized, the route will be unshifted onto the route set (and will have the highest priority).</description>
                <examples>
                    <example><![CDATA[routes.addRoute('route_name','/route/path',{params});<br/>
routes.addRoute('/route/path',{params});<br/>
routes.addRoute('/route/path');]]></example>
                </examples>
                <exceptions>
                    <exception type="ActiveRoutes.Errors.NoMethodInRoute"/>
                    <exception type="ActiveRoutes.Errors.NoObjectInRoute"/>
                    <exception type="ActiveRoutes.Errors.NoPathInRoute"/>
                </exceptions>
            </method>
            <method name="back" scope="instance">
                <description>Calls to the previous dispatched route in the history.</description>
                <return-types>
                    <return-type type="Boolean"/>
                </return-types>
            </method>
            <method name="dispatch" scope="instance">
                <description>Will match() the given path and call the dispatcher if one is found.</description>
                <examples>
                    <example><![CDATA[    var routes = new ActiveRoutes([['post','/blog/post/:id',{object:'blog',method: 'post'}]]);
    routes.dispatch('/blog/post/5');
    //by default calls Blog.post({object:'blog',method: 'post',id: 5});]]></example>
                </examples>
                <parameters>
                    <parameter name="path" usage="required" type="String"/>
                </parameters>
                <exceptions>
                    <exception type="ActiveRoutes.Errors.UnresolvableUrl"/>
                </exceptions>
            </method>
            <method name="getError" scope="instance">
                <description>If match() returns false, the error it generates can be retrieved with this function.</description>
                <return-types>
                    <return-type type="mixed">
                        <description>String or null</description>
                    </return-type>
                </return-types>
            </method>
            <method name="match" scope="instance">
                <examples>
                    <example><![CDATA[var route = routes.match('/blog/post/5');<br/>
route == {object: 'blog',method: 'post', id: 5};]]></example>
                </examples>
                <parameters>
                    <parameter name="path" usage="required" type="String"/>
                </parameters>
                <return-types>
                    <return-type type="mixed">
                        <description>false if no match, otherwise the matching route.</description>
                    </return-type>
                </return-types>
            </method>
            <method name="next" scope="instance">
                <description>Calls to the next dispatched route in the history if back() has already been called.</description>
                <return-types>
                    <return-type type="Boolean"/>
                </return-types>
            </method>
            <method name="urlFor" scope="instance">
                <examples>
                    <example><![CDATA[var routes = new ActiveRoutes([['post','/blog/post/:id',{object:'blog',method: 'post'}]]);<br/>
routes.urlFor({object: 'blog',method: 'post', id: 5}) == '/blog/post/5';]]></example>
                </examples>
                <parameters>
                    <parameter name="params" usage="optional" type="Object"/>
                </parameters>
                <return-types>
                    <return-type type="String"/>
                </return-types>
                <exceptions>
                    <exception type="ActiveRoutes.Errors.NamedRouteDoesNotExistError"/>
                </exceptions>
            </method>
        </methods>
    </class>
    <class type="ActiveSupport" superclass="Object">
        <description>Provides a number of methods from the Prototype.js framework, without modifying any built in prototypes to ensure compatibility and portability.</description>
        <properties>
            <property name="logErrors" access="read-write" scope="static" type="Boolean"/>
            <property name="throwErrors" access="read-write" scope="static" type="Boolean"/>
        </properties>
        <methods>
            <method name="arrayFrom" scope="static">
                <description>Returns an array from an array or array like object.</description>
                <parameters>
                    <parameter name="object" usage="required" type="Object">
                        <description>Any iterable object (Array, NodeList, arguments)</description>
                    </parameter>
                </parameters>
                <return-types>
                    <return-type type="Array"/>
                </return-types>
            </method>
            <method name="bind" scope="static">
                <description>Emulates Prototype&apos;s Function.prototype.bind. Unlike Prototype&apos;s version you must explicitly use curry() to pass extra arguments to the bound function.</description>
                <parameters>
                    <parameter name="func" usage="required" type="Function"/>
                    <parameter name="object" usage="required" type="Object">
                        <description>object will be in scope as &quot;this&quot; when func is called.</description>
                    </parameter>
                </parameters>
                <return-types>
                    <return-type type="Function"/>
                </return-types>
            </method>
            <method name="camelize" scope="static">
                <description>Emulates Prototype&apos;s String.prototype.camelize</description>
                <parameters>
                    <parameter name="str" usage="required" type="String"/>
                    <parameter name="capitalize" usage="optional" type="Boolean"/>
                </parameters>
                <return-types>
                    <return-type type="String"/>
                </return-types>
            </method>
            <method name="clone" scope="static">
                <description>Emulates Prototype&apos;s Object.clone</description>
                <parameters>
                    <parameter name="object" usage="required" type="Object"/>
                </parameters>
                <return-types>
                    <return-type type="Object"/>
                </return-types>
            </method>
            <method name="createError" scope="static">
                <description>Creates an Error object (but does not throw it).</description>
                <parameters>
                    <parameter name="message" usage="required" type="String"/>
                </parameters>
                <return-types>
                    <return-type type="null"/>
                </return-types>
            </method>
            <method name="curry" scope="static">
                <description>Emulates Prototype&apos;s Function.prototype.curry.</description>
                <parameters>
                    <parameter name="func" usage="required" type="Function"/>
                </parameters>
                <return-types>
                    <return-type type="Function"/>
                </return-types>
            </method>
            <method name="dateFormat" scope="static">
                <description>See: http://blog.stevenlevithan.com/archives/date-time-format If convert_to_local_time is true the Date object will be assume to be GMT and be converted from GMT to the local time. Local time will be the local time of the server if running server side, or local time of the client side if running in the browser.</description>
                <examples>
                    <example><![CDATA[    ActiveSupport.dateFormat('yyyy-mm-dd HH:MM:ss');]]></example>
                </examples>
                <parameters>
                    <parameter name="date" usage="required" type="Date"/>
                    <parameter name="format" usage="required" type="String"/>
                    <parameter name="convert_to_local_time" usage="optional" type="Boolean"/>
                </parameters>
                <return-types>
                    <return-type type="String"/>
                </return-types>
            </method>
            <method name="dateFromDateTime" scope="static">
                <description>Generates a JavaScript Date object from a MySQL DATETIME formatted string (yyyy-mm-dd HH:MM:ss).</description>
                <parameters>
                    <parameter name="date_time" usage="required" type="String"/>
                </parameters>
                <return-types>
                    <return-type type="Date"/>
                </return-types>
            </method>
            <method name="extend" scope="static">
                <description>Emulates Prototype&apos;s Object.extend</description>
                <parameters>
                    <parameter name="destination" usage="required" type="Object"/>
                    <parameter name="source" usage="required" type="Object"/>
                </parameters>
                <return-types>
                    <return-type type="Object"/>
                </return-types>
            </method>
            <method name="getClass" scope="static">
                <description>Returns a class if it exists. If the context (default window / global context) does not contain the class, but does have a __noSuchMethod__ property, it will attempt to call context [ class_name ] () to trigger the __noSuchMethod__ handler.</description>
                <parameters>
                    <parameter name="class_name" usage="required" type="String"/>
                    <parameter name="context" usage="required" type="Object"/>
                </parameters>
                <return-types>
                    <return-type type="Mixed"/>
                </return-types>
            </method>
            <method name="getGlobalContext" scope="static">
                <description>Returns the global context object (window in most implementations).</description>
                <return-types>
                    <return-type type="Object"/>
                </return-types>
            </method>
            <method name="indexOf" scope="static">
                <description>Emulates Array.indexOf for implementations that do not support it.</description>
                <parameters>
                    <parameter name="array" usage="required" type="Array"/>
                    <parameter name="item" usage="required" type="mixed"/>
                </parameters>
                <return-types>
                    <return-type type="Number"/>
                </return-types>
            </method>
            <method name="isArray" scope="static">
                <parameters>
                    <parameter name="object" usage="required" type="mixed"/>
                </parameters>
                <return-types>
                    <return-type type="Boolean"/>
                </return-types>
            </method>
            <method name="JSONFromObject" scope="static">
                <description>Serializes an object to a JSON string.</description>
                <parameters>
                    <parameter name="object" usage="required" type="Object"/>
                </parameters>
                <return-types>
                    <return-type type="String">
                        <description>json</description>
                    </return-type>
                </return-types>
            </method>
            <method name="keys" scope="static">
                <description>Returns an array of keys from an object.</description>
                <parameters>
                    <parameter name="object" usage="required" type="Object"/>
                </parameters>
                <return-types>
                    <return-type type="Array"/>
                </return-types>
            </method>
            <method name="log" scope="static">
                <description>Logs a message to the available logging resource. Accepts a variable number of arguments.</description>
            </method>
            <method name="proc" scope="static">
                <description>If the value passed is a function the value passed will be returned, otherwise a function returning the value passed will be returned.</description>
                <parameters>
                    <parameter name="proc" usage="required" type="mixed"/>
                </parameters>
                <return-types>
                    <return-type type="Function"/>
                </return-types>
            </method>
            <method name="synchronize" scope="static">
            </method>
            <method name="throwError" scope="static">
                <description>Accepts a variable number of arguments, that may be logged and thrown in</description>
                <parameters>
                    <parameter name="error" usage="required" type="Error"/>
                </parameters>
                <return-types>
                    <return-type type="null"/>
                </return-types>
            </method>
            <method name="underscore" scope="static">
                <description>Emulates Prototype&apos;s String.prototype.underscore</description>
                <parameters>
                    <parameter name="str" usage="required" type="String"/>
                </parameters>
                <return-types>
                    <return-type type="String"/>
                </return-types>
            </method>
            <method name="value" scope="static">
                <description>If the value passed is a function, the function is called and the value returned, otherwise the value passed in is returned.</description>
                <parameters>
                    <parameter name="value" usage="required" type="mixed"/>
                </parameters>
                <return-types>
                    <return-type type="scalar"/>
                </return-types>
            </method>
            <method name="without" scope="static">
                <description>Returns an array without the given item.</description>
                <parameters>
                    <parameter name="arr" usage="required" type="Array"/>
                    <parameter name="item" usage="required" type="mixed">
                        <description>to remove</description>
                    </parameter>
                </parameters>
                <return-types>
                    <return-type type="Array"/>
                </return-types>
            </method>
            <method name="wrap" scope="static">
                <description>Returns a function wrapped around the original function.</description>
                <examples>
                    <example><![CDATA[    String.prototype.capitalize = String.prototype.capitalize.wrap( 
    function(proceed, eachWord) { 
        if (eachWord && this.include(" ")) {
            // capitalize each word in the string
            return this.split(" ").invoke("capitalize").join(" ");
        } else {
            // proceed using the original function
            return proceed(); 
        }
    });]]></example>
                </examples>
                <parameters>
                    <parameter name="func" usage="required" type="Function"/>
                    <parameter name="wrapper" usage="required" type="Function"/>
                </parameters>
                <return-types>
                    <return-type type="Function">
                        <description>wrapped</description>
                    </return-type>
                </return-types>
            </method>
            <method name="XMLFromObject" scope="static">
                <description>Serializes an object to an XML string.</description>
                <parameters>
                    <parameter name="outer_key_name" usage="required" type="String"/>
                    <parameter name="object" usage="required" type="Object"/>
                </parameters>
                <return-types>
                    <return-type type="String">
                        <description>xml</description>
                    </return-type>
                </return-types>
            </method>
        </methods>
    </class>
    <class type="ActiveSupport.Inflector" superclass="Object">
        <description>A port of Rails Inflector class.</description>
        <methods>
            <method name="ordinalize" scope="static">
                <description>Generates an orginalized version of a number as a string (9th, 2nd, etc)</description>
                <parameters>
                    <parameter name="number" usage="required" type="Number"/>
                </parameters>
                <return-types>
                    <return-type type="String"/>
                </return-types>
            </method>
            <method name="pluralize" scope="static">
                <description>Generates a plural version of an english word.</description>
                <parameters>
                    <parameter name="word" usage="required" type="String"/>
                </parameters>
                <return-types>
                    <return-type type="String"/>
                </return-types>
            </method>
            <method name="singularize" scope="static">
                <description>Generates a singular version of an english word.</description>
                <parameters>
                    <parameter name="word" usage="required" type="String"/>
                </parameters>
                <return-types>
                    <return-type type="String"/>
                </return-types>
            </method>
        </methods>
    </class>
    <class type="ActiveSupport.JSON" superclass="Object">
        <description>Provides JSON support if a native implementation is not available.</description>
        <methods>
            <method name="parse" scope="static">
                <parameters>
                    <parameter name="text" usage="required" type="String"/>
                </parameters>
                <return-types>
                    <return-type type="Object"/>
                </return-types>
            </method>
            <method name="stringify" scope="static">
                <parameters>
                    <parameter name="value" usage="required" type="Object"/>
                </parameters>
                <return-types>
                    <return-type type="String"/>
                </return-types>
            </method>
        </methods>
    </class>
    <class type="ActiveView" superclass="Object">
        <examples>
            <example><![CDATA[ActiveView.js
===============
Tutorial coming soon.]]></example>
        </examples>
        <methods>
            <method name="render" scope="static">
                <description>This method is not usually called directly but is utilized by data bindings and ActiveControllers. This method is normalizes or renders a variety of inputs. Strings or Element objects are returned untouched, ActiveView instances will have their DOM container returned, ActiveView classes will be rendered and the DOM container returned. If a function is passed in it will be called with the passed scope. That function should return a string or Element.</description>
                <parameters>
                    <parameter name="content" usage="required" type="mixed"/>
                    <parameter name="scope" usage="optional" type="Object"/>
                </parameters>
                <return-types>
                    <return-type type="mixed"/>
                </return-types>
            </method>
        </methods>
    </class>
</javascript>
